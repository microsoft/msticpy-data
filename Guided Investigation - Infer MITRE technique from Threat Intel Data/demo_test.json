{
    "cells": [
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "# Guided Exploration - Infer MITRE technique from Threat Intel Data\n",
       "\n",
       "__Notebook Version:__ 1.0<br>\n",
       "__Notebook Author:__ Vani Asawa<br>\n",
       "__Python Version:__ >=Python 3.8<br>\n",
       "__Platforms Supported:__  Azure Machine Learning Notebooks\n",
       "     \n",
       "__Data Source Required:__ No<br>\n",
       "__Data Source:__ None<br>\n",
       "\n",
       "__GPU Compute Required:__ No<br>\n",
       "__GPU Compute Recommended:__ Yes\n",
       "\n",
       "__Requirements Path:__ ```Guided Exploration - Infer MITRE technique from Threat Intel Data/requirements.txt```<br>\n",
       "\n",
       "## Description\n",
       "\n",
       "**Cyber Threat Intelligence** (CTI) provides a framework for threat analysts to document the operations of a threat actor group, and record the findings of their investigations of specific cyber attack incidents. \n",
       "\n",
       "With the increasing number and sophistication of attacks occuring across organization's workspace, CTI allows organisations to develop a more robust and proactive security posture, better detect threat vulnerabilities in their infrastructre, and adopt security solutions and policies that allow them to better protect their environment. For example, **Indicators of Compromise (IoC)** represent network artifacts of a cyber intrusion, and are widely used in intrusion detection systems and antivirus softwares to detect future attacks.\n",
       "\n",
       "**Threat Intel Data** is another form of CTI, which comprises of rich, unstructured, textual data describing the tools, techniques, and procedures used by threat actor groups in a cyber operation. Historically, TI data is made available to the security community in the form of blog posts, reports, and white papers. With the increasing numebr of cyber attacks, it is not scalable to manually process this growing corpus of TI data to understand the motivations, capabilities, and TTPs associated with an actor group. Additionally, TI data does not facilitate easy extraction of IoCs, which, if documented in the report, can result in the loss of known indicators in the threat intelligence corpus. This opens up several avenues for **Machine Learning**, more particularly **Natural Language Processing** (NLP), to identify TTPs and IoCs from this data.\n",
       "\n",
       "The **MITRE ATT&CK** framework is an openly-sourced knowledge base of TTPs used by adversaries across enterprise and mobile applications. MITRE TTPs allow people and organizations to proactively identify vulnerabilites in their system, based on the behaviors, methods, and patterns of activity used by an actor group in different stages of a cyber operation.\n",
       "\n",
       "***In this notebook, we use NLP to \n",
       "1. *Detect MITRE TTPs*, & \n",
       "2. *Extract IoCs*\n",
       "\n",
       "from unstructured, English text-based Threat Intel data. We also provide some explainability into the TTP predictions made by our NLP model, by identifying specific words or phrases in the input TI data that contribute to the prediction.***\n",
       "\n",
       "## Prerequisites\n",
       "**Please do not run the notebook cells all at once**. The cells need to be run sequentially, and successfully executed before proceeding with the remainder of the notebook.\n",
       "\n",
       "## Table of Contents\n",
       "\n",
       "1. Imports\n",
       "2. Configure Input Data and Model Parameters\n",
       "3. Get Model Artifacts\n",
       "4. Process TI Data\n",
       "5. Inference\n",
       "6. Explainability"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {},
      "outputs": [
       {
        "name": "stdout",
        "output_type": "stream",
        "text": [
         "Updated git hooks.\n",
         "Git LFS initialized.\n"
        ]
       }
      ],
      "source": [
       "!git lfs install"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
       {
        "name": "stderr",
        "output_type": "stream",
        "text": [
         "WARNING: 'git lfs clone' is deprecated and will not be updated\n",
         "          with new flags from 'git clone'\n",
         "\n",
         "'git clone' has been updated in upstream Git to have comparable\n",
         "speeds to 'git lfs clone'.\n",
         "Cloning into 'msticpy-data'...\n"
        ]
       }
      ],
      "source": [
       "! git clone -b mitre-tagging https://github.com/microsoft/msticpy-data.git"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
       {
        "name": "stderr",
        "output_type": "stream",
        "text": [
         "fatal: remote msticpy-data already exists.\n"
        ]
       }
      ],
      "source": [
       "! git remote add msticpy-data https://github.com/microsoft/msticpy-data.git"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {},
      "outputs": [],
      "source": [
       "! git fetch msticpy-data"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 10,
      "metadata": {},
      "outputs": [
       {
        "name": "stderr",
        "output_type": "stream",
        "text": [
         "error: Your local changes to the following files would be overwritten by checkout:\n",
         "\tGuided Investigation - Infer MITRE technique from Threat Intel data/demo.ipynb\n",
         "\tGuided Investigation - Infer MITRE technique from Threat Intel data/requirements.txt\n",
         "\tGuided Investigation - Infer MITRE technique from Threat Intel data/utils/inference.py\n",
         "\tGuided Investigation - Infer MITRE technique from Threat Intel data/utils/storage.py\n",
         "Please commit your changes or stash them before you switch branches.\n",
         "error: Your local changes to the following files would be overwritten by checkout:\n",
         "\tGuided Investigation - Infer MITRE technique from Threat Intel data/utils/configs.py\n",
         "Please commit your changes or stash them before you switch branches.\n",
         "Aborting\n"
        ]
       }
      ],
      "source": [
       "! git checkout msticpy-data/mitre-tagging "
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "cd \"Guided Investigation - Infer MITRE technique from Threat Intel data/artifacts\"\n",
       "git clone -b mitre-inference https://github.com/microsoft/msticpy-data --no-checkout msticpy-data --depth 1\n",
       "cd msticpy-data\n",
       "git sparse-checkout init --cone\n",
       "git sparse-checkout set mitre-inference-models\n",
       "git checkout"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "git remote add tensorflow https://github.com/tensorflow/tensorflow.git\n",
       "git fetch tensorflow\n",
       "git checkout tensorflow/master -- tools"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {},
      "outputs": [
       {
        "name": "stdout",
        "output_type": "stream",
        "text": [
         "c:\\Users\\vaasawa\\Documents\\GitHub\\Azure-Sentinel-Notebooks\\Guided Investigation - Infer MITRE technique from Threat Intel data\n"
        ]
       }
      ],
      "source": [
       "! cd"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Installations\n",
       "\n",
       "Please download the packages in ```Guided Exploration - Infer MITRE technique from Threat Intel Data/requirements.txt``` in your virtual environment before running the rest of the cells in the notebook."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {},
      "outputs": [
       {
        "data": {
         "text/plain": [
          "1"
         ]
        },
        "execution_count": 1,
        "metadata": {},
        "output_type": "execute_result"
       }
      ],
      "outputs": [],
      "source": [
       "import os\n",
       "import sys\n",
       "sys.path.append(os.getcwd())\n",
       "\n",
       "############### REQUIREMENTS.TXT NEEDS TO BE UPDATED ################\n",
       "# requirements_path = os.path.join(os.getcwd(), 'requirements.txt')\n",
       "# os.system(f\"pip install -r {requirements_path}\")"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Imports\n",
       "\n",
       "The modules used to run this notebook can be found under ```Guided Exploration - Infer MITRE technique from Threat Intel Data/utils/*```"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [
       {
        "name": "stderr",
        "output_type": "stream",
        "text": [
         "[nltk_data] Downloading package stopwords to\n",
         "[nltk_data]     C:\\Users\\vaasawa\\AppData\\Roaming\\nltk_data...\n",
         "[nltk_data]   Package stopwords is already up-to-date!\n",
         "[nltk_data] Downloading package wordnet to\n",
         "[nltk_data]     C:\\Users\\vaasawa\\AppData\\Roaming\\nltk_data...\n",
         "[nltk_data]   Package wordnet is already up-to-date!\n",
         "[nltk_data] Downloading package omw-1.4 to\n",
         "[nltk_data]     C:\\Users\\vaasawa\\AppData\\Roaming\\nltk_data...\n",
         "[nltk_data]   Package omw-1.4 is already up-to-date!\n",
         "[nltk_data] Downloading package punkt to\n",
         "[nltk_data]     C:\\Users\\vaasawa\\AppData\\Roaming\\nltk_data...\n",
         "[nltk_data]   Package punkt is already up-to-date!\n"
        ]
       },
       {
        "data": {
         "text/html": [
          "\n",
          "This product includes GeoLite2 data created by MaxMind, available from\n",
          "<a href=\"https://www.maxmind.com\">https://www.maxmind.com</a>.\n"
         ],
         "text/plain": [
          "<IPython.core.display.HTML object>"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       }
      ],
      "source": [
       "import torch\n",
       "import utils\n",
       "from utils import (\n",
       "    configs as config_utils,\n",
       "    storage as storage_utils,\n",
       "    inference as inference_utils,\n",
       "    process as process_utils\n",
       ")"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Configure Input Data and Model Parameters\n",
       "\n",
       "The notebook requires the following parameters from the user:\n",
       "1. ***Threat Intel Data***: Unstructured, English text data that the user would like to process through the NLP model. If you are inputting multiple text reports in the widget, please input the reports separated by an empty line. Do not include any commas, punctuations, or brackets before and after the reports. <br>\n",
       "\n",
       "- For example: Here, we are processing three different threat reports, which are separated by an empty line. The length of each report can be more than one sentence. In this example, for the purposes of succinct documentation, the length of each report is 1 sentence.\n",
       "        \n",
       "        ```\n",
       "        Like many threat groups, TG-3390 conducts strategic web compromises (SWCs), also known as watering hole attacks, on websites associated with the target organization's vertical or demographic to increase the likelihood of finding victims with relevant information.\n",
       "\n",
       "        Threat groups use strategic web compromises (SWCs), also known as watering hole attacks, to target a wide array of potential victims\n",
       "        Threat groups use strategic web compromises (SWCs), also known as watering hole attacks, to target a wide array of potential victims.\n",
       "\n",
       "        A build tool is likely being used by these attackers that allows the operator to configure details such as C2 addresses, C2 encryption keys, and a campaign code\n",
       "        A build tool is likely being used by these attackers that allows the operator to configure details such as C2 addresses, C2 encryption keys, and a campaign code.\n",
       "        ```\n",
       "\n",
       "2. ***Select NLP Model***: We have trained four variations of GPT-2 transformer models using publicly-available threat intel datasets that map TI data to MITRE TTPs. \n",
       "- *distilgpt2* models are 40% lower in storage size than the *gpt2* models <br>\n",
       "\n",
       "- *distilgpt2-1024* and *gpt2-1024* models process more word tokens in a single threat input statement than the *distilgpt2-512* and *distilgpt2-1024* models, which can be particularly useful if your threat intel data is long. <br>\n",
       "\n",
       "- Default model: **distilgpt2_512** <br><br>\n",
       "\n",
       "3. ***Minimum Score Threshold***: The TTP predictions for a sample TI input data have an associated confidence score from the NLP model, ranging from 0 (less confident) to 1 (most confident). Filter the results to predictions with confidence >= threshold configured by the user. <br>\n",
       "\n",
       "- Default threshold: **0.7** <br> <br>\n",
       "\n",
       "4. ***Chunk Threat Intel Data?***: \n",
       "- One of the limitations of the transformer models is that they can only process inputs upto a certain length, after which the rest of the report is discarded. \n",
       "- As a result, the model will lose out on potentially important information about the actor's TTPs, described in the latter parts of the report. \n",
       "- If a single threat report in your input is longer than 3 sentences, we recommend **chunking** - The model will process the sentences in your input data in batches of 3 sentences, hence assigning a TTP prediction for each chunk of data, and processing the entire report. <br>\n",
       "\n",
       "- Default value: **Yes** <br><br>\n",
       "\n",
       "5. ***Extract Indicators of Compromise (IoCs)***: Extract IoCs from the input TI data. <br>\n",
       "\n",
       "- Default value: **Yes** <br><br>\n",
       "\n",
       "6. ***Get NLP Model Explainability***: Obtain further insights into which words and phrases in your input data contributed to the TTP prediction. <br>\n",
       "\n",
       "- Default value: **Yes** <br><br>\n"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {},
      "outputs": [
       {
        "data": {
         "application/vnd.jupyter.widget-view+json": {
          "model_id": "ae3b9130b7d74c0cbb0bc1ee42a49e92",
          "model_id": "4f0141817504498db107364549df4a37",
          "version_major": 2,
          "version_minor": 0
         },
         "text/plain": [
          "Textarea(value='', description='Threat Intel Data:', layout=Layout(height='200px', width='80%'), style=Descrip…"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       },
       {
        "data": {
         "application/vnd.jupyter.widget-view+json": {
          "model_id": "4de2da04f4ea4c6087e48f56a0215dd6",
          "model_id": "d0fbcebebc6040a39ee821272ccacf9c",
          "version_major": 2,
          "version_minor": 0
         },
         "text/plain": [
          "Select(description='Select NLP Model: ', layout=Layout(height='80px', width='50%'), options=('distilgpt2-512',…"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       },
       {
        "data": {
         "application/vnd.jupyter.widget-view+json": {
          "model_id": "866a3659707c44e59522d1ba42c73545",
          "model_id": "848761dbfa934710bcb239867bf823d0",
          "version_major": 2,
          "version_minor": 0
         },
         "text/plain": [
          "FloatSlider(value=0.7, description='Minimum Score Threshold: ', layout=Layout(height='30px', width='50%'), max…"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       },
       {
        "data": {
         "application/vnd.jupyter.widget-view+json": {
          "model_id": "e2b6713bf7e9470a9cf652fa635082d8",
          "model_id": "a46bac904f7345d48460e043f5f37378",
          "version_major": 2,
          "version_minor": 0
         },
         "text/plain": [
          "Select(description='Chunk Threat Intel data?: ', layout=Layout(height='80px', width='50%'), options=('Yes', 'N…"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       },
       {
        "data": {
         "application/vnd.jupyter.widget-view+json": {
          "model_id": "93d508320bb244e0a80e6935ebf67789",
          "model_id": "fb5ee516c4f24ee49a0a150046603c24",
          "version_major": 2,
          "version_minor": 0
         },
         "text/plain": [
          "Select(description='Extract Indicators Of Compromise (IoCs)?: ', layout=Layout(height='80px', width='50%'), op…"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       },
       {
        "data": {
         "application/vnd.jupyter.widget-view+json": {
          "model_id": "631e61aa7b694feca2a48acb84c6db7e",
          "model_id": "46771fa925cc4ab0a96f529ef29bf9a6",
          "version_major": 2,
          "version_minor": 0
         },
         "text/plain": [
          "Select(description='Get NLP Model Explainability?: ', layout=Layout(height='80px', width='50%'), options=('Yes…"
         ]
        },
        "metadata": {},
        "output_type": "display_data"
       }
      ],
      "source": [
       "all_config_widgets = config_utils.configure_model_parameters()\n",
       "for k in all_config_widgets.keys():\n",
       "    display(all_config_widgets[k])"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 4,
      "execution_count": 5,
      "metadata": {},
      "outputs": [
       {
        "name": "stdout",
        "output_type": "stream",
        "text": [
         "#################### SUMMARY #################### \n",
         "\n",
         "Threat Intel (TI) Data: [\n",
         "Threat Intel (TI) Reports: [\n",
         "\n",
         "\t\"Like many threat groups, TG-3390 conducts strategic web compromises (SWCs), also known as watering hole attacks, on websites associated with the target organization's vertical or demographic to increase the likelihood of finding victims with relevant information.\", \n",
         "\n",
         "\t\"Threat groups use strategic web compromises (SWCs), also known as watering hole attacks, to target a wide array of potential victims.\", \n",
         "\n",
         "\t\"['hELLO']\"\n",
         "\t\"A build tool is likely being used by these attackers that allows the operator to configure details such as C2 addresses, C2 encryption keys, and a campaign code.\"\n",
         "\n",
         "]\n",
         "\n",
         "# of TI entries: 1\n",
         "# of TI reports: 3\n",
         "\n",
         "NLP Model: distilgpt2-512\n",
         "NLP Model: gpt-1024\n",
         "\n",
         "Minimum Score Threshold: 0.7\n",
         "Minimum Score Threshold: 0.0\n",
         "\n",
         "Chunk Threat Intel data?: Yes\n",
         "\n",
         "Extract Indicators Of Compromise (IoCs)?: Yes\n",
         "\n",
         "Get NLP Model Explainability?: Yes\n",
         "\n",
         "################################################# \n",
         "\n"
        ]
       }
      ],
      "source": [
       "set_configs = {\n",
       "    k: v.value for k, v in all_config_widgets.items()\n",
       "}\n",
       "\n",
       "configs = config_utils.format_user_configuration(set_configs, verbose=True)"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Get Model Artifacts"
       "## Get Model Artifacts\n",
       "\n"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "asset_storage = storage_utils.AssetStorage(\n",
       "    model_name = configs['model']\n",
       ")\n",
       "\n",
       "model = asset_storage.model\n",
       "device = asset_storage.device\n",
       "tokenizer = asset_storage.tokenizer\n",
       "labels = asset_storage.labels"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "inference_model = inference_utils.InferenceClassificationPipeline(\n",
       "    model = model,\n",
       "    tokenizer = tokenizer,\n",
       "    device = device.type\n",
       ")"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Process TI Data"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "processed_data_object = process_utils.ProcessData(\n",
       "    configs = configs\n",
       ")\n",
       "\n",
       "processed_data_object.go()"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Inference"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "outputs = inference_model.go(processed_data_object.processed_data)"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "inference_df = inference_utils.format_predictions(\n",
       "    configs = configs,\n",
       "    processed_data_object = processed_data_object,\n",
       "    labels = labels,\n",
       "    outputs = outputs,\n",
       "    classifier = inference_model.classifier_max_scores\n",
       ")"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "print(f'Shape of DF: {inference_df.shape}')\n",
       "\n",
       "print('Sample Result: ')\n",
       "if inference_df.empty:\n",
       "    print('Empty Dataframe')\n",
       "else:\n",
       "    display(inference_df.head(1))"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Explainability - Visualisation"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
       "row_index = 0\n",
       "\n",
       "inference_utils = inferece_utils.process_shap_explainability_for_row(\n",
       "    inference_df, row_index\n",
       ")"
      ]
     }
    ],
    "metadata": {
     "kernelspec": {
      "display_name": "Python 3.8.3 ('base')",
      "language": "python",
      "name": "python3"
     },
     "language_info": {
      "codemirror_mode": {
       "name": "ipython",
       "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.3"
     },
     "orig_nbformat": 4,
    "nbformat": 4,
    "nbformat_minor": 2
   }